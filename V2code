// =======================
// Embedded Web Pages
// =======================

// WiFi setup HTML page
const char wifiSetupHTML[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>WiFi Setup - Mixer Grinder</title>
<style>
body { font-family: Arial, sans-serif; background-color: #f8f8f8; }
.container { max-width: 350px; margin: auto; margin-top: 40px; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 5px rgba(0,0,0,0.1); }
input { width: 100%; padding: 10px; margin: 6px 0; box-sizing: border-box; }
button { padding: 10px; background: #4CAF50; border: none; color: white; width: 100%; border-radius: 4px; font-size: 16px; }
h2 { text-align: center; }
</style>
</head>
<body>
<div class="container">
  <h2>WiFi Setup</h2>
  <form action="/savewifi" method="POST">
    <input type="text" name="ssid" placeholder="WiFi SSID" required>
    <input type="password" name="pass" placeholder="Password" required>
    <button type="submit">Save & Connect</button>
  </form>
</div>
</body>
</html>
)rawliteral";

// Main control dashboard page
const char indexHTML[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Smart Mixer Grinder</title>
<style>
body { font-family: Arial, sans-serif; background: #f0f2f5; margin: 0; }
header { background: #4CAF50; color: white; padding: 15px; font-size: 20px; text-align: center; }
.menu { background: #333; overflow: hidden; display: flex; }
.menu button { flex: 1; padding: 14px; background: #333; color: white; border: none; font-size: 16px; }
.menu button:hover { background: #111; }
.section { display: none; padding: 20px; }
.active { display: block; }
h2 { margin-top: 0; }
.card { background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
label { display: block; margin-top: 10px; }
input, select { width: 100%; padding: 8px; box-sizing: border-box; margin-top: 6px; }
button.action { margin-top: 10px; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; }
.toggle { display: flex; align-items: center; margin-top: 8px; }
.toggle input { margin-left: 10px; }
.stats { font-size: 16px; line-height: 1.5; }
.recipe { border: 1px solid #ddd; padding: 10px; border-radius: 5px; margin-bottom: 10px; background: #fafafa; }
</style>
</head>
<body>
<header>Smart Mixer Grinder</header>
<div class="menu">
  <button onclick="showSection('home')">Home</button>
  <button onclick="showSection('myrecipes')">My Recipes</button>
  <button onclick="showSection('publicrecipes')">Public Recipes</button>
</div>

<div id="home" class="section active">
  <div class="card">
    <h2>Motor Speed</h2>
    <select id="motorSpeed" onchange="updateMotorSpeed()">
      <option value="0">Off</option>
      <option value="1">Level 1 (30%)</option>
      <option value="2">Level 2 (60%)</option>
      <option value="3">Level 3 (100%)</option>
    </select>
    <h2>UV Sterilization</h2>
    <label class="toggle">Enable UV <input type="checkbox" id="uvToggle" onchange="updateUV()"></label>
  </div>
  <div class="card stats">
    <h2>Power Stats</h2>
    Voltage: <span id="voltage">--</span> V<br>
    Current: <span id="current">--</span> A<br>
    Power: <span id="power">--</span> W
  </div>
</div>

<div id="myrecipes" class="section">
  <div class="card">
    <h2>Create Recipe</h2>
    <input type="text" id="recipeName" placeholder="Recipe Name">
    <textarea id="ingredients" placeholder="Ingredients (name,weight,calories per line)"></textarea>
    <input type="number" id="servingSize" placeholder="Serving Size">
    <select id="recipeMotorSpeed">
      <option value="1">Level 1</option>
      <option value="2">Level 2</option>
      <option value="3">Level 3</option>
    </select>
    <input type="number" id="recipeTime" placeholder="Run Time (seconds)">
    <button class="action" onclick="saveRecipe()">Save Recipe</button>
  </div>
  <div id="recipeList"></div>
</div>

<div id="publicrecipes" class="section">
  <div class="card">
    <h2>Public Recipes</h2>
    <button class="action" onclick="loadPublicRecipes()">Load from Internet</button>
    <div id="publicList"></div>
  </div>
</div>

<script>
var ws;

function initWebSocket() {
  ws = new WebSocket('ws://' + window.location.host + '/ws');
  ws.onmessage = function(evt) {
    let data = JSON.parse(evt.data);
    document.getElementById("voltage").innerText = data.voltage.toFixed(2);
    document.getElementById("current").innerText = data.current.toFixed(2);
    document.getElementById("power").innerText = data.power.toFixed(2);
    document.getElementById("motorSpeed").value = data.motorSpeed;
    document.getElementById("uvToggle").checked = data.uvOn;
  };
}

function showSection(id) {
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function updateMotorSpeed() {
  let val = parseInt(document.getElementById('motorSpeed').value);
  ws.send(JSON.stringify({motorSpeed: val}));
}

function updateUV() {
  let on = document.getElementById('uvToggle').checked;
  ws.send(JSON.stringify({uvOn: on}));
}

function saveRecipe() {
  let name = document.getElementById('recipeName').value;
  let ing = document.getElementById('ingredients').value.trim().split("\\n").map(line => {
    let p = line.split(',');
    return { name: p[0], weight: p[1], calories: p[2] };
  });
  let serving = parseInt(document.getElementById('servingSize').value);
  let speed = parseInt(document.getElementById('recipeMotorSpeed').value);
  let time = parseInt(document.getElementById('recipeTime').value);

  fetch('/api/recipes').then(r => r.json()).then(recipes => {
    recipes.push({ name, ingredients: ing, serving, speed, time });
    return fetch('/api/recipes', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(recipes) });
  }).then(() => loadRecipes());
}

function loadRecipes() {
  fetch('/api/recipes').then(r => r.json()).then(data => {
    let html = '';
    data.forEach((r,i) => {
      let totalCal = r.ingredients.reduce((a,b)=>a+parseFloat(b.calories), 0);
      html += `<div class="recipe"><b>${r.name}</b> - ${totalCal} Cal<br><button onclick="deleteRecipe(${i})">Delete</button></div>`;
    });
    document.getElementById('recipeList').innerHTML = html;
  });
}

function deleteRecipe(index) {
  fetch('/api/recipes').then(r => r.json()).then(data => {
    data.splice(index,1);
    return fetch('/api/recipes', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(data) });
  }).then(() => loadRecipes());
}

function loadPublicRecipes() {
  fetch('/api/public').then(r => r.json()).then(data => {
    let html = '';
    data.forEach(r => {
      let totalCal = r.ingredients.reduce((a,b)=>a+parseFloat(b.calories), 0);
      html += `<div class="recipe"><b>${r.name}</b> - ${totalCal} Cal<br><button onclick='importRecipe(${JSON.stringify(r)})'>Import</button></div>`;
    });
    document.getElementById('publicList').innerHTML = html;
  });
}

function importRecipe(recipe) {
  fetch('/api/recipes').then(r => r.json()).then(recipes => {
    recipes.push(recipe);
    return fetch('/api/recipes', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(recipes) });
  }).then(() => alert("Imported!"));
}

window.onload = function() {
  initWebSocket();
  loadRecipes();
}
</script>
</body>
</html>
)rawliteral";


#include <WiFi.h>
#include <ESPAsyncWebServer.h>
#include <AsyncTCP.h>
#include <ArduinoJson.h>
#include "EmonLib.h"
#include <Preferences.h>

// Motor & UV pin definitions
#define MOTOR_PIN 25
#define UV_PIN 26

// Motor PWM configuration
#define PWM_CHANNEL 0
#define PWM_FREQ 5000
#define PWM_RES 8

// Voltage and current sensor pins
#define V1 34
#define I1 35
#define CV1 1000
#define CI1 1000

// Include Preferences for storing WiFi info
Preferences preferences;

// Web server and WebSocket server on port 80
AsyncWebServer server(80);
AsyncWebSocket ws("/ws");

// Energy monitoring object
EnergyMonitor emon1;

// Stores if ESP32 connected as station
bool isSTA = false;

String savedSSID;
String savedPass;

// Runtime motor speed state (0-3)
uint8_t motorSpeedLevel = 0;  // 0=off,1=30%,2=60%,3=100%

// UV LED state
bool uvOn = false;

// In-memory recipe storage (JSON string)
String recipesJSON = "[]";

// --- Utility functions ---

// Set PWM duty from motor speed level
void setMotorSpeed(uint8_t level) {
  uint8_t duty = 0;
  if (level == 1) duty = 76;  // 30% of 255
  else if (level == 2) duty = 153; // 60%
  else if (level == 3) duty = 255;  // 100%
  motorSpeedLevel = level;
  ledcWrite(PWM_CHANNEL, duty);
}

// Set UV LED GPIO
void setUV(bool on) {
  uvOn = on;
  digitalWrite(UV_PIN, uvOn ? HIGH : LOW);
}

// Read power data, return JSON string
String getPowerDataJSON() {
  emon1.calcVI(20, 2000);
  float voltage = emon1.Vrms;
  float current = emon1.Irms;
  float power = voltage * current;
  StaticJsonDocument<200> doc;
  doc["voltage"] = voltage;
  doc["current"] = current;
  doc["power"] = power;
  doc["motorSpeed"] = motorSpeedLevel;
  doc["uvOn"] = uvOn;
  String out;
  serializeJson(doc, out);
  return out;
}

// Save WiFi credentials in preferences
void saveWiFiCredentials(String ssid, String pass) {
  preferences.begin("wifi", false);
  preferences.putString("ssid", ssid);
  preferences.putString("pass", pass);
  preferences.end();
}

// Load WiFi credentials from preferences
bool loadWiFiCredentials() {
  preferences.begin("wifi", true);
  savedSSID = preferences.getString("ssid", "");
  savedPass = preferences.getString("pass", "");
  preferences.end();
  return savedSSID.length() > 0;
}

// Connect to WiFi as station
bool connectToWiFi() {
  if (loadWiFiCredentials()) {
    WiFi.begin(savedSSID.c_str(), savedPass.c_str());
    Serial.print("Connecting to WiFi");
    unsigned long startTime = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - startTime < 10000) {
      Serial.print(".");
      delay(500);
    }
    Serial.println();
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("Connected to WiFi!");
      Serial.print("IP: ");
      Serial.println(WiFi.localIP());
      return true;
    }
  }
  return false;
}

// Start Access Point mode with captive portal
void startAPMode() {
  WiFi.softAP("MixerGrinder_Setup", "12345678");
  Serial.println("Started AP Mode: MixerGrinder_Setup");
  
  // Serve WiFi setup page on root "/"
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send_P(200, "text/html", wifiSetupHTML);
  });

  // Handle WiFi credentials submission
  server.on("/savewifi", HTTP_POST, [](AsyncWebServerRequest *request) {
    if(request->hasParam("ssid", true) && request->hasParam("pass", true)) {
      String newSSID = request->getParam("ssid", true)->value();
      String newPass = request->getParam("pass", true)->value();
      saveWiFiCredentials(newSSID, newPass);
      request->send(200, "text/plain", "Saved WiFi settings. Rebooting...");
      delay(1000);
      ESP.restart();
    } else {
      request->send(400, "text/plain", "Missing SSID or Password");
    }
  });
  
  server.begin();
}

// Handle embedded web pages & APIs in Station mode
void setupAPIRoutes() {
  // Serve main UI page
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", indexHTML);
  });

  // WebSocket event handler
  ws.onEvent([](AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len) {
    if (type == WS_EVT_CONNECT) {
      Serial.println("Client connected to WebSocket");
    } else if (type == WS_EVT_DISCONNECT) {
      Serial.println("Client disconnected from WebSocket");
    } else if (type == WS_EVT_DATA) {
      String msg = String((char*)data).substring(0, len);
      StaticJsonDocument<256> doc;
      DeserializationError error = deserializeJson(doc, msg);
      if(!error) {
        if (doc.containsKey("motorSpeed")) {
          setMotorSpeed(doc["motorSpeed"]);
        }
        if (doc.containsKey("uvOn")) {
          setUV(doc["uvOn"]);
        }
      }
    }
  });
  server.addHandler(&ws);

  // API: Return power data
  server.on("/api/power", HTTP_GET, [](AsyncWebServerRequest *req){
    req->send(200, "application/json", getPowerDataJSON());
  });

  // API: Get all saved recipes
  server.on("/api/recipes", HTTP_GET, [](AsyncWebServerRequest *req){
    req->send(200, "application/json", recipesJSON);
  });

  // API: Save recipes (overwrite all)
  server.on("/api/recipes", HTTP_POST, [](AsyncWebServerRequest *req){
    if(req->hasParam("plain", true)) {
      String body = req->getParam("plain", true)->value();
      StaticJsonDocument<1024> doc;
      if(deserializeJson(doc, body) == DeserializationError::Ok) {
        recipesJSON = body;
        req->send(200, "text/plain", "Recipes saved");
      } else {
        req->send(400, "text/plain", "Invalid JSON");
      }
    } else {
      req->send(400, "text/plain", "Missing JSON body");
    }
  });

  // API: Fetch Public Recipes from mock URL (example, not implemented here)
  server.on("/api/public", HTTP_GET, [](AsyncWebServerRequest *req){
    // Just respond with empty array for now, UI will fetch real API online
    req->send(200, "application/json", "[]");
  });

  server.begin();
}

// Update real-time stats every few seconds via WebSocket broadcast
void notifyClientsPower() {
  if (ws.count() > 0) {
    ws.textAll(getPowerDataJSON());
  }
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  // Motor and UV GPIO setup
  pinMode(UV_PIN, OUTPUT);
  digitalWrite(UV_PIN, LOW);
  
  ledcSetup(PWM_CHANNEL, PWM_FREQ, PWM_RES);
  ledcAttachPin(MOTOR_PIN, PWM_CHANNEL);
  setMotorSpeed(0);  // motor off initially

  // Sensor setup
  analogSetPinAttenuation(V1, ADC_11db);
  analogSetPinAttenuation(I1, ADC_11db);
  emon1.voltage(V1, CV1, 1.732);
  emon1.current(I1, CI1);

  // Initialize Preferences
  preferences.begin("wifi", false);

  if (connectToWiFi()) {
    isSTA = true;
    Serial.println("Running in Station mode");
    setupAPIRoutes();
  } else {
    isSTA = false;
    Serial.println("Running in AP mode");
    startAPMode();
  }
}

void loop() {
  if (isSTA) {
    static unsigned long lastNotify = 0;
    if (millis() - lastNotify > 2000) {
      notifyClientsPower();
      lastNotify = millis();
    }
  }
  // AsyncWebServer handles clients asynchronously
}
